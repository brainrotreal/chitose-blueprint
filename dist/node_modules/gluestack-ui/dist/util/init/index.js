var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "os", "../../config", "util", "path", "@clack/prompts", "fs-extra", "../config", "..", "../../dependencies", "../config/next-config-helper", "../config/expo-config-helper", "../config/react-native-config-helper", "../check-next-version", "fs-extra", "./modify-layout"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InitializeGlueStack = void 0;
    exports.commonInitialization = commonInitialization;
    const os_1 = __importDefault(require("os"));
    const config_1 = require("../../config");
    const util_1 = require("util");
    const path_1 = __importStar(require("path"));
    const prompts_1 = require("@clack/prompts");
    const fs_extra_1 = __importStar(require("fs-extra"));
    const config_2 = require("../config");
    const __1 = require("..");
    const dependencies_1 = require("../../dependencies");
    const next_config_helper_1 = require("../config/next-config-helper");
    const expo_config_helper_1 = require("../config/expo-config-helper");
    const react_native_config_helper_1 = require("../config/react-native-config-helper");
    const check_next_version_1 = require("../check-next-version");
    const fs_extra_2 = require("fs-extra");
    const modify_layout_1 = require("./modify-layout");
    const _currDir = process.cwd();
    const _homeDir = os_1.default.homedir();
    // Get templates from GitHub repository
    const getTemplatesPath = () => {
        return (0, path_1.join)(_homeDir, config_1.config.gluestackDir, config_1.config.templatesDir);
    };
    const readFileAsync = (0, util_1.promisify)(fs_extra_1.default.readFile);
    const writeFileAsync = (0, util_1.promisify)(fs_extra_1.default.writeFile);
    const InitializeGlueStack = (_a) => __awaiter(void 0, [_a], void 0, function* ({ projectType = 'library', isTemplate = false, }) {
        try {
            const initializeStatus = yield (0, config_2.checkIfInitialized)(_currDir);
            if (initializeStatus) {
                prompts_1.log.info(`\x1b[33mgluestack-ui is already initialized in the project, use 'npx gluestack-ui help' command to continue\x1b[0m`);
                process.exit(1);
            }
            const isNextjs15 = yield (0, check_next_version_1.checkNextVersion)();
            const confirmOverride = isTemplate
                ? true
                : yield overrideWarning(filesToOverride(projectType));
            console.log(`\n\x1b[1mInitializing gluestack-ui v3...\x1b[0m\n`);
            yield (0, __1.cloneRepositoryAtRoot)((0, path_1.join)(_homeDir, config_1.config.gluestackDir));
            const inputComponent = [config_1.config.providerComponent];
            // Check dependencies for the provider component
            const { components: providerDependencies } = yield (0, __1.checkComponentDependencies)(inputComponent);
            let additionalDependencies = yield (0, dependencies_1.getProjectBasedDependencies)(projectType, config_1.config.style);
            let versionManager = (0, __1.findLockFileType)();
            if (!versionManager) {
                versionManager = yield (0, __1.promptVersionManager)();
            }
            yield (0, __1.installDependencies)(inputComponent, versionManager, additionalDependencies);
            const s = (0, prompts_1.spinner)();
            s.start('⏳ Generating project configuration. This might take a couple of minutes...');
            yield generateProjectConfigAndInit(projectType, confirmOverride, isNextjs15);
            yield addProvider(isNextjs15);
            // Add provider dependencies (like toast) as essential components
            yield addEssentialComponents(providerDependencies);
            s.stop(`\x1b[32mProject configuration generated.\x1b[0m`);
            prompts_1.log.step('Please refer the above link for more details --> \x1b[33mhttps://gluestack.io/ui/docs/home/overview/introduction \x1b[0m');
            prompts_1.log.success(`\x1b[32mDone!\x1b[0m Initialized \x1b[1mgluestack-ui v3\x1b[0m in the project`);
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError occured in init. (${err})\x1b[0m`);
            process.exit(1);
        }
    });
    exports.InitializeGlueStack = InitializeGlueStack;
    function addProvider(isNextjs15) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const targetPath = (0, path_1.join)(_currDir, config_1.config.writableComponentsPath, config_1.config.providerComponent);
                const sourcePath = (0, path_1.join)(_homeDir, config_1.config.gluestackDir, config_1.config.componentsResourcePath, config_1.config.providerComponent);
                yield fs_extra_1.default.ensureDir(targetPath);
                // Copy only files from the root directory, excluding subdirectories and dependencies.json
                const files = yield fs_extra_1.default.readdir(sourcePath, { withFileTypes: true });
                for (const file of files) {
                    if (file.isFile() && file.name !== 'dependencies.json') {
                        yield fs_extra_1.default.copy((0, path_1.join)(sourcePath, file.name), (0, path_1.join)(targetPath, file.name), { overwrite: true });
                    }
                }
                if (isNextjs15) {
                    const templatesPath = getTemplatesPath();
                    const providerContent = yield (0, fs_extra_2.readFile)((0, path_1.join)(templatesPath, 'nextjs', 'next15', 'index.web.tsx'), 'utf8');
                    yield (0, fs_extra_1.writeFile)((0, path_1.join)(targetPath, 'index.web.tsx'), providerContent, 'utf8');
                }
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError occured while adding the provider.\x1b[0m`);
                throw new Error(err.message);
            }
        });
    }
    function addEssentialComponents(components) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (components.length === 0) {
                    return;
                }
                for (const component of components) {
                    const targetPath = (0, path_1.join)(_currDir, config_1.config.writableComponentsPath, component);
                    const sourcePath = (0, path_1.join)(_homeDir, config_1.config.gluestackDir, config_1.config.componentsResourcePath, component);
                    yield fs_extra_1.default.ensureDir(targetPath);
                    // Copy only files from the root directory, excluding subdirectories and dependencies.json
                    const files = yield fs_extra_1.default.readdir(sourcePath, { withFileTypes: true });
                    for (const file of files) {
                        if (file.isFile() && file.name !== 'dependencies.json') {
                            yield fs_extra_1.default.copy((0, path_1.join)(sourcePath, file.name), (0, path_1.join)(targetPath, file.name), { overwrite: true });
                        }
                    }
                }
                prompts_1.log.step(`✅ Added provider dependencies: ${components.join(', ')}`);
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError occurred while adding provider dependencies.\x1b[0m`);
                throw new Error(err.message);
            }
        });
    }
    //update tailwind.config.js
    function updateTailwindConfig(resolvedConfig, projectType) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const templatesPath = getTemplatesPath();
                const tailwindConfigRootPath = (0, path_1.join)(templatesPath, 'tailwind.config.js');
                const tailwindConfigPath = resolvedConfig.tailwind.config;
                yield fs_extra_1.default.copy(tailwindConfigRootPath, tailwindConfigPath);
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError: ${err}\x1b[0m`);
            }
        });
    }
    //updateConfig helper, create default tsconfig.json
    function createDefaultTSConfig() {
        return {
            compilerOptions: {
                paths: {
                    '@/*': ['./*'],
                },
            },
            exclude: ['node_modules'],
        };
    }
    // updateConfig helper, read tsconfig.json
    function readTSConfig(configPath) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return JSON.parse(yield readFileAsync(configPath, 'utf8'));
            }
            catch (_a) {
                return createDefaultTSConfig();
            }
        });
    }
    // updateConfig helper, update paths in tsconfig.json
    function updatePaths(paths, key, newValues) {
        paths[key] = Array.from(new Set([...(paths[key] || []), ...newValues]));
    }
    //update tsconfig.json
    function updateTSConfig(projectType, resolvedConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const configPath = resolvedConfig.config.tsConfig;
                let tsConfig = yield readTSConfig(configPath);
                let tailwindConfig = resolvedConfig.tailwind.config;
                const tailwindConfigFileName = path_1.default.basename(tailwindConfig);
                tsConfig.compilerOptions = tsConfig.compilerOptions || {};
                tsConfig.compilerOptions.paths = tsConfig.compilerOptions.paths || {};
                // Next.js project specific configuration
                if (projectType === config_1.config.nextJsProject) {
                    tsConfig.compilerOptions.jsxImportSource = 'nativewind';
                }
                updatePaths(tsConfig.compilerOptions.paths, '@/*', ['./*']);
                updatePaths(tsConfig.compilerOptions.paths, 'tailwind.config', [
                    `./${tailwindConfigFileName}`,
                ]);
                yield writeFileAsync(configPath, JSON.stringify(tsConfig, null, 2), 'utf8');
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError occurred while updating tsconfig.json: ${err.message}\x1b[0m`);
            }
        });
    }
    //update global.css
    function updateGlobalCss(resolvedConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const globalCSSPath = resolvedConfig.tailwind.css;
                const templatesPath = getTemplatesPath();
                // Determine which template to use based on the target filename
                const cssFileName = path_1.default.basename(globalCSSPath);
                const templateCSSFile = cssFileName === 'globals.css' ? 'globals.css' : 'global.css';
                const templateContent = yield fs_extra_1.default.readFile((0, path_1.join)(templatesPath, 'common', templateCSSFile), 'utf8');
                // Read existing content
                let existingContent = '';
                try {
                    existingContent = yield fs_extra_1.default.readFile(globalCSSPath, 'utf8');
                }
                catch (error) {
                    // File doesn't exist, create it with template content
                    yield fs_extra_1.default.writeFile(globalCSSPath, templateContent, 'utf8');
                    return;
                }
                // Clean and normalize the existing content
                let updatedContent = cleanAndNormalizeCss(existingContent, templateContent);
                // Only write if content has changed
                if (updatedContent !== existingContent) {
                    yield fs_extra_1.default.writeFile(globalCSSPath, updatedContent, 'utf8');
                    prompts_1.log.info(`✅ Updated ${cssFileName} with Tailwind directives`);
                }
                else {
                    prompts_1.log.info(`${cssFileName} already contains proper Tailwind directives`);
                }
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError updating global CSS: ${err.message}\x1b[0m`);
            }
        });
    }
    function cleanAndNormalizeCss(existingContent, templateContent) {
        // Split content into lines for easier processing
        let lines = existingContent.split('\n');
        // Remove old tailwindcss import if it exists
        lines = lines.filter(line => !line.trim().match(/^@import\s+["']tailwindcss["'];?\s*$/i));
        // Check if any of the required tailwind directives exist
        const requiredDirectives = [
            '@tailwind base;',
            '@tailwind components;',
            '@tailwind utilities;'
        ];
        const existingDirectives = new Set();
        // Find existing tailwind directives and their positions
        const directiveLines = [];
        lines.forEach((line, index) => {
            const trimmedLine = line.trim();
            requiredDirectives.forEach(directive => {
                const directiveWithoutSemicolon = directive.replace(';', '');
                if (trimmedLine === directive ||
                    trimmedLine === directiveWithoutSemicolon ||
                    trimmedLine === directive.replace(';', '') + ' ') {
                    existingDirectives.add(directive);
                    directiveLines.push(index);
                }
            });
        });
        // If all directives already exist, return original content
        if (existingDirectives.size === requiredDirectives.length) {
            return lines.join('\n');
        }
        // Remove existing tailwind directive lines to avoid duplicates
        lines = lines.filter((_, index) => !directiveLines.includes(index));
        // Find the best position to insert tailwind directives
        let insertPosition = 0;
        // Look for existing imports to insert after them
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line.startsWith('@import') || line.startsWith('@charset')) {
                insertPosition = i + 1;
            }
            else if (line.length > 0 && !line.startsWith('/*') && !line.startsWith('*')) {
                // Found first non-comment, non-import line
                break;
            }
        }
        // Insert the template content (tailwind directives) at the appropriate position
        const templateLines = templateContent.split('\n').filter(line => line.trim());
        // Insert template lines
        lines.splice(insertPosition, 0, ...templateLines);
        // Clean up multiple consecutive empty lines
        const cleanedLines = [];
        let consecutiveEmptyLines = 0;
        for (const line of lines) {
            if (line.trim() === '') {
                consecutiveEmptyLines++;
                if (consecutiveEmptyLines <= 1) { // Allow max 1 consecutive empty line
                    cleanedLines.push(line);
                }
            }
            else {
                consecutiveEmptyLines = 0;
                cleanedLines.push(line);
            }
        }
        // Ensure there's a newline at the end
        let result = cleanedLines.join('\n');
        if (!result.endsWith('\n') && result.length > 0) {
            result += '\n';
        }
        return result;
    }
    function commonInitialization(projectType, resolvedConfig, permission) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                //get resolvedFileNames from the resolvedConfig
                const resolvedConfigValues = Object.values(resolvedConfig).flat(Infinity);
                const flattenedConfigValues = resolvedConfigValues.flatMap((value) => typeof value === 'string' ? value : Object.values(value));
                const resolvedConfigFileNames = flattenedConfigValues
                    .map((filePath) => typeof filePath === 'string' ? path_1.default.parse(filePath).base : null)
                    .filter((fileName) => fileName !== null);
                const templatesPath = getTemplatesPath();
                const resourcePath = (0, path_1.join)(templatesPath, projectType);
                //if any filepath
                if ((0, fs_extra_1.existsSync)(resourcePath)) {
                    const filesAndFolders = fs_extra_1.default.readdirSync(resourcePath);
                    //if any fileName in resourcePath matches with the resolvedConfigFileNames, copy the file
                    yield Promise.all(filesAndFolders.map((file) => __awaiter(this, void 0, void 0, function* () {
                        const templateFileName = path_1.default.parse(file).name;
                        const templateFileExt = path_1.default.parse(file).ext;
                        // Check if any resolved config file matches this template file
                        const matchingConfigFile = resolvedConfigFileNames.find((configFileName) => {
                            const configName = path_1.default.parse(configFileName).name;
                            const configExt = path_1.default.parse(configFileName).ext;
                            // For config files that can have multiple extensions, prioritize exact matches
                            if (configName === templateFileName &&
                                (templateFileName === 'next.config' ||
                                    templateFileName === 'postcss.config' ||
                                    templateFileName === 'tailwind.config')) {
                                // If extensions match exactly, this is the preferred match
                                if (configExt === templateFileExt) {
                                    return true;
                                }
                                // Only allow extension mismatch if no template with matching extension exists
                                const hasMatchingExtensionTemplate = filesAndFolders.some((otherFile) => {
                                    const otherTemplateName = path_1.default.parse(otherFile).name;
                                    const otherTemplateExt = path_1.default.parse(otherFile).ext;
                                    return (otherTemplateName === templateFileName &&
                                        otherTemplateExt === configExt);
                                });
                                return !hasMatchingExtensionTemplate;
                            }
                            // For other files, require exact match
                            return (configName === templateFileName && configExt === templateFileExt);
                        });
                        if (matchingConfigFile) {
                            const targetFileName = matchingConfigFile;
                            const targetPath = (0, path_1.join)(_currDir, targetFileName);
                            // Ensure the directory exists
                            yield fs_extra_1.default.ensureDir(path_1.default.dirname(targetPath));
                            // Copy the file with error handling
                            try {
                                yield fs_extra_1.default.copy((0, path_1.join)(resourcePath, file), targetPath, {
                                    overwrite: true,
                                    errorOnExist: false,
                                });
                            }
                            catch (err) {
                                // If the file doesn't exist, create it
                                if (err.code === 'ENOENT') {
                                    yield fs_extra_1.default.writeFile(targetPath, yield fs_extra_1.default.readFile((0, path_1.join)(resourcePath, file)));
                                }
                                else {
                                    throw err;
                                }
                            }
                        }
                    })));
                }
                //add nativewind-env.d.ts contents
                const nativewindEnvPath = (0, path_1.join)(templatesPath, 'common', 'nativewind-env.d.ts');
                yield fs_extra_1.default.copy(nativewindEnvPath, (0, path_1.join)(_currDir, 'nativewind-env.d.ts'));
                permission && (yield updateTSConfig(projectType, resolvedConfig));
                permission && (yield updateGlobalCss(resolvedConfig));
                yield updateTailwindConfig(resolvedConfig, projectType);
                // Automatically modify layout files to add GluestackUIProvider wrapper
                yield (0, modify_layout_1.modifyLayoutFilesAutomatically)(projectType, resolvedConfig, permission === true);
            }
            catch (err) {
                throw new Error(err.message);
            }
        });
    }
    //generate project config and initialize
    function generateProjectConfigAndInit(projectType, confirmOverride, isNextjs15) {
        return __awaiter(this, void 0, void 0, function* () {
            let permission;
            if (confirmOverride === false || typeof confirmOverride === 'symbol') {
                permission = false;
            }
            else
                permission = true;
            let resolvedConfig; // Initialize with a default value
            if (projectType !== 'library') {
                switch (projectType) {
                    case config_1.config.nextJsProject:
                        yield (0, next_config_helper_1.generateConfigNextApp)(permission, isNextjs15);
                        break;
                    case config_1.config.expoProject:
                        yield (0, expo_config_helper_1.generateConfigExpoApp)(permission);
                        break;
                    case config_1.config.reactNativeCLIProject:
                        yield (0, react_native_config_helper_1.generateConfigRNApp)(permission);
                        break;
                    default:
                        break;
                }
            }
            else {
                //write function to generate config for monorepo or library
                yield (0, config_2.generateMonoRepoConfig)();
            }
            return resolvedConfig;
        });
    }
    //files to override in the project directory data
    const filesToOverride = (projectType) => {
        switch (projectType) {
            case config_1.config.nextJsProject:
                return [
                    'next.config.*',
                    'tailwind.config.*',
                    'postcss.config.*',
                    'globals.css',
                    'tsconfig.json',
                ];
            case config_1.config.expoProject:
                return [
                    'babel.config.js',
                    'metro.config.js',
                    'tailwind.config.*',
                    'global.css',
                    'tsconfig.json',
                ];
            case config_1.config.reactNativeCLIProject:
                return [
                    'babel.config.js',
                    'metro.config.js',
                    'global.css',
                    'tsconfig.json',
                ];
            default:
                return [];
        }
    };
    // Helper function to calculate the length of the string without ANSI escape codes
    function getStringLengthWithoutAnsi(string) {
        return string.replace(/\x1b\[[0-9;]*m/g, '').length;
    }
    //overriding warning message
    function overrideWarning(files) {
        return __awaiter(this, void 0, void 0, function* () {
            if (files.length === 0) {
                return true;
            }
            const boxLength = 90;
            console.log(`\x1b[33m
  ┌${'─'.repeat(boxLength)}┐
  │                                                                                          │
  │  NOTE: Files to get modified                                                             │
  │                                                                                          │
  │  The command you've run is attempting to modify certain files in your project,           │
  │  if already exist. Here's what's happening:                                              │
  │                                                                                          │
${files
                .map((file) => `  │  - ${file}${' '.repeat(boxLength - getStringLengthWithoutAnsi(`  │  - ${file}`) + 3)}│`)
                .join('\n')}
  │                                                                                          │
  └${'─'.repeat(boxLength)}┘
  \x1b[0m`);
            const confirmInput = yield (0, prompts_1.confirm)({
                message: `\x1b[33mProceed with caution. Make sure to commit your changes before proceeding. Continue?
    \x1b[0m`,
            });
            if (confirmInput === false) {
                prompts_1.log.info('Skipping making changes in files. Please refer docs for making the changes manually --> \x1b[33mhttps://gluestack.io/ui/docs/home/getting-started/installation\x1b[0m');
            }
            return confirmInput;
        });
    }
});
