var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs-extra", "chalk", "os", "path", "@clack/prompts", "../../config", ".."], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.componentAdder = void 0;
    const fs_extra_1 = __importDefault(require("fs-extra"));
    const chalk_1 = __importDefault(require("chalk"));
    const os_1 = __importDefault(require("os"));
    const path_1 = require("path");
    const prompts_1 = require("@clack/prompts");
    const config_1 = require("../../config");
    const __1 = require("..");
    const _homeDir = os_1.default.homedir();
    let existingComponentsChecked = false;
    const componentAdder = (_a) => __awaiter(void 0, [_a], void 0, function* ({ addAll = false, componentArgs = [], }) {
        try {
            let componentsToAdd = componentArgs;
            if (componentsToAdd.length > 0 || addAll) {
                if (!addAll &&
                    (componentsToAdd === null || componentsToAdd === void 0 ? void 0 : componentsToAdd.length) &&
                    !(yield checkIfComponentIsValid(componentsToAdd))) {
                    prompts_1.log.error(chalk_1.default.red(`Invalid names entered. Kindly check and choose a valid component name.`));
                    return;
                }
                console.log(`\n\x1b[1mAdding new component...\x1b[0m\n`);
                let requestedComponents = addAll
                    ? yield (0, __1.getAllComponents)()
                    : componentsToAdd;
                const { components: additionalComponents } = yield (0, __1.checkComponentDependencies)(requestedComponents);
                const allComponentsToInstall = [
                    ...new Set([...requestedComponents, ...additionalComponents]),
                ];
                const updatedComponents = !existingComponentsChecked && allComponentsToInstall.length
                    ? yield isComponentInProject(allComponentsToInstall)
                    : allComponentsToInstall;
                const count = updatedComponents.length;
                if (count === 0) {
                    prompts_1.log.step(`No new components to add.`);
                    return;
                }
                prompts_1.log.step(`Adding ${count} component${count > 1 ? 's' : ''}:`);
                console.log(`${chalk_1.default.cyan('â³')} ${updatedComponents
                    .map((component) => chalk_1.default.yellow(component))
                    .join(', ')}`);
                let versionManager = config_1.config.packageManager || (0, __1.findLockFileType)();
                if (!versionManager) {
                    versionManager = yield (0, __1.promptVersionManager)();
                }
                yield (0, __1.installDependencies)(updatedComponents, versionManager);
                for (const component of updatedComponents) {
                    const targetPath = (0, path_1.join)(__1.projectRootPath, config_1.config.writableComponentsPath, component);
                    yield writeComponent(component, targetPath);
                }
                prompts_1.log.success(`\x1b[32mDone!\x1b[0m Added ${count} component${count > 1 ? 's' : ''} to the project.`);
            }
        }
        catch (error) {
            prompts_1.log.error(`\x1b[31mError: ${error.message}\x1b[0m`);
        }
    });
    exports.componentAdder = componentAdder;
    const isComponentInProject = (allComponentsToInstall) => __awaiter(void 0, void 0, void 0, function* () {
        const currentComponents = fs_extra_1.default
            .readdirSync((0, path_1.join)(__1.projectRootPath, config_1.config.writableComponentsPath))
            .filter((item) => {
            const itemPath = (0, path_1.join)(__1.projectRootPath, config_1.config.writableComponentsPath, item);
            return fs_extra_1.default.statSync(itemPath).isDirectory();
        });
        const existingComponents = allComponentsToInstall.filter((component) => currentComponents.includes(component));
        if (existingComponents.length > 0) {
            const shouldContinue = yield (0, prompts_1.confirm)({
                message: `\x1b[33mThe following components are already present in your project: ${existingComponents.join(', ')}. Do you want to overwrite them?\x1b[0m`,
            });
            const componentsToAdd = shouldContinue
                ? allComponentsToInstall
                : allComponentsToInstall.filter((component) => !existingComponents.includes(component));
            existingComponentsChecked = true;
            return componentsToAdd;
        }
        return allComponentsToInstall;
    });
    function checkIfComponentIsValid(components) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const allComponents = yield (0, __1.getAllComponents)();
                // Allow gluestack-ui-provider to be added manually even though it's excluded from getAllComponents
                const allowedComponents = [...allComponents, config_1.config.providerComponent];
                return components.every((component) => allowedComponents.includes(component));
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError fetching available components: ${err.message}\x1b[0m`);
                return false;
            }
        });
    }
    const writeComponent = (component, targetPath) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            yield fs_extra_1.default.ensureDir(targetPath);
            const sourcePath = (0, path_1.join)(_homeDir, config_1.config.gluestackDir, config_1.config.componentsResourcePath, component);
            const files = yield fs_extra_1.default.readdir(sourcePath, { withFileTypes: true });
            for (const file of files) {
                if (file.isFile() && file.name !== 'dependencies.json') {
                    yield fs_extra_1.default.copy((0, path_1.join)(sourcePath, file.name), (0, path_1.join)(targetPath, file.name), { overwrite: true });
                }
            }
        }
        catch (error) {
            prompts_1.log.error(`\x1b[31mError: ${error.message}\x1b[0m`);
        }
    });
});
