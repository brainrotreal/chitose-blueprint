var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "os", "fs-extra", "simple-git", "../config", "child_process", "find-package-json", "path", "@clack/prompts", "../dependencies"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dashToPascal = exports.pascalToDash = exports.addIndexFile = exports.installDependencies = exports.projectRootPath = exports.checkWritablePath = exports.getAllComponents = exports.cloneRepositoryAtRoot = exports.promptVersionManager = void 0;
    exports.findLockFileType = findLockFileType;
    exports.detectProjectType = detectProjectType;
    exports.isValidPath = isValidPath;
    exports.removeHyphen = removeHyphen;
    exports.getRelativePath = getRelativePath;
    exports.ensureFilesPromise = ensureFilesPromise;
    exports.getPackageMangerFlag = getPackageMangerFlag;
    exports.checkComponentDependencies = checkComponentDependencies;
    const os_1 = __importDefault(require("os"));
    const fs_extra_1 = __importStar(require("fs-extra"));
    const simple_git_1 = __importDefault(require("simple-git"));
    const config_1 = require("../config");
    const child_process_1 = require("child_process");
    const find_package_json_1 = __importDefault(require("find-package-json"));
    const path_1 = require("path");
    const prompts_1 = require("@clack/prompts");
    const dependencies_1 = require("../dependencies");
    const homeDir = os_1.default.homedir();
    const currDir = process.cwd();
    const getPackageJsonPath = () => {
        var f = (0, find_package_json_1.default)(currDir);
        return f.next().filename || '';
    };
    const rootPackageJsonPath = getPackageJsonPath();
    const projectRootPath = (0, path_1.dirname)(rootPackageJsonPath);
    exports.projectRootPath = projectRootPath;
    const getAllComponents = () => __awaiter(void 0, void 0, void 0, function* () {
        const componentList = fs_extra_1.default
            .readdirSync((0, path_1.join)(homeDir, config_1.config.gluestackDir, config_1.config.componentsResourcePath))
            .filter((file) => !['.tsx', '.ts', '.jsx', '.js', '.json'].includes((0, path_1.extname)(file).toLowerCase()) &&
            file !== config_1.config.providerComponent &&
            !config_1.config.ignoreComponents.includes(file));
        return componentList;
    });
    exports.getAllComponents = getAllComponents;
    function checkComponentDependencies(components) {
        return __awaiter(this, void 0, void 0, function* () {
            const additionalDependencies = {
                components: [],
            };
            const processedComponents = new Set();
            const processComponent = (component) => __awaiter(this, void 0, void 0, function* () {
                if (processedComponents.has(component)) {
                    return;
                }
                processedComponents.add(component);
                const dependencyConfig = yield (0, dependencies_1.getComponentDependencies)(component);
                // Add additional components
                if (dependencyConfig.additionalComponents) {
                    for (const additionalComponent of dependencyConfig.additionalComponents) {
                        if (!additionalDependencies.components.includes(additionalComponent)) {
                            additionalDependencies.components.push(additionalComponent);
                            // Recursively process dependencies of this component
                            yield processComponent(additionalComponent);
                        }
                    }
                }
            });
            // Process all requested components
            for (const component of components) {
                yield processComponent(component);
            }
            return additionalDependencies;
        });
    }
    const cloneRepositoryAtRoot = (rootPath) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const clonedRepoExists = yield checkIfFolderExists(rootPath);
            if (clonedRepoExists) {
                const git = (0, simple_git_1.default)(rootPath);
                const currBranch = yield git.branchLocal();
                if (currBranch.current !== config_1.config.branchName) {
                    fs_extra_1.default.removeSync(rootPath);
                    yield cloneComponentRepo(rootPath, config_1.config.repoUrl);
                }
                if (currBranch.current === config_1.config.branchName) {
                    prompts_1.log.step('Repository already cloned.');
                    yield pullComponentRepo((0, path_1.join)(homeDir, config_1.config.gluestackDir));
                }
            }
            else {
                yield cloneComponentRepo(rootPath, config_1.config.repoUrl);
            }
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31m Cloning failed.\x1b[0m`);
            throw new Error(err.message);
        }
    });
    exports.cloneRepositoryAtRoot = cloneRepositoryAtRoot;
    const cloneComponentRepo = (targetPath, gitURL) => __awaiter(void 0, void 0, void 0, function* () {
        const git = (0, simple_git_1.default)();
        const s = (0, prompts_1.spinner)();
        s.start('⏳ Cloning repository...');
        try {
            yield git.clone(gitURL, targetPath, [
                '--depth=1',
                '--branch',
                config_1.config.branchName,
            ]);
            s.stop('\x1b[32m' + 'Cloning successful.' + '\x1b[0m');
        }
        catch (err) {
            s.stop('\x1b[31m' + 'Cloning failed' + '\x1b[0m');
            throw new Error(err.message);
        }
    });
    const pullComponentRepo = (targetpath) => __awaiter(void 0, void 0, void 0, function* () {
        const s = (0, prompts_1.spinner)();
        s.start('⏳ Pulling latest changes...');
        let retry = 0;
        let success = false;
        while (!success && retry < 3) {
            try {
                yield wait(1000);
                yield tryGitPull(targetpath);
                success = true;
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
                prompts_1.log.error(`\x1b[31mPulling failed - retrying... (Attempt ${retry + 1})\x1b[0m`);
                retry++;
            }
        }
        if (!success) {
            s.stop('\x1b[31m' + 'Pulling failed!' + '\x1b[0m');
            throw new Error('Error pulling remote branch!');
        }
        else
            s.stop('Git pull successful.');
    });
    const tryGitPull = (targetPath) => __awaiter(void 0, void 0, void 0, function* () {
        const git = (0, simple_git_1.default)(targetPath);
        if (fs_extra_1.default.existsSync(targetPath)) {
            yield git.pull('origin', config_1.config.branchName);
        }
        else
            prompts_1.log.error('\x1b[31m' + 'Target path does not exist' + '\x1b[0m');
    });
    const wait = (msec) => new Promise((resolve, _) => {
        setTimeout(resolve, msec);
    });
    //checking from cwd
    function findLockFileType() {
        const lockFiles = {
            'package-lock.json': 'npm',
            'yarn.lock': 'yarn',
            'pnpm-lock.yaml': 'pnpm',
            'bun.lockb': 'bun',
        };
        let dir = currDir;
        while (dir !== (0, path_1.dirname)(dir)) {
            for (const [file, manager] of Object.entries(lockFiles)) {
                if (fs_extra_1.default.existsSync((0, path_1.join)(dir, file)))
                    return manager;
            }
            dir = (0, path_1.dirname)(dir);
        }
        return null;
    }
    function getPackageMangerFlag(options) {
        if (options.useBun) {
            config_1.config.packageManager = 'bun';
            return 'bun';
        }
        if (options.usePnpm) {
            config_1.config.packageManager = 'pnpm';
            return 'pnpm';
        }
        if (options.useYarn) {
            config_1.config.packageManager = 'yarn';
            return 'yarn';
        }
        if (options.useNpm) {
            config_1.config.packageManager = 'npm';
            return 'npm';
        }
    }
    const promptVersionManager = () => __awaiter(void 0, void 0, void 0, function* () {
        const packageManager = yield (0, prompts_1.select)({
            message: 'No lockfile detected. Please select a package manager to install dependencies:',
            options: [
                { value: 'npm', label: 'npm', hint: 'recommended' },
                { value: 'yarn', label: 'yarn' },
                { value: 'pnpm', label: 'pnpm' },
                { value: 'bun', label: 'bun' },
            ],
        });
        if ((0, prompts_1.isCancel)(packageManager)) {
            (0, prompts_1.cancel)('Operation cancelled.');
            process.exit(0);
        }
        return packageManager;
    });
    exports.promptVersionManager = promptVersionManager;
    function ensureLegacyPeerDeps() {
        return __awaiter(this, void 0, void 0, function* () {
            const commands = {
                npm: 'npm config --location=project set legacy-peer-deps=true',
                yarn: 'yarn config set legacy-peer-deps true',
                pnpm: 'pnpm config set legacy-peer-deps true',
            };
            const command = config_1.config.packageManager && commands[config_1.config.packageManager];
            if (command)
                (0, child_process_1.execSync)(command);
        });
    }
    const installDependencies = (input, versionManager, additionalDependencies) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            let versionManager = config_1.config.packageManager ||
                findLockFileType() ||
                (yield (0, exports.promptVersionManager)());
            config_1.config.packageManager = versionManager;
            yield ensureLegacyPeerDeps();
            const dependenciesToInstall = { dependencies: {}, devDependencies: {} };
            //add additional dependencies if any
            if (additionalDependencies) {
                Object.assign(dependenciesToInstall.dependencies, additionalDependencies.dependencies);
                (additionalDependencies === null || additionalDependencies === void 0 ? void 0 : additionalDependencies.devDependencies) &&
                    Object.assign(dependenciesToInstall.devDependencies, additionalDependencies === null || additionalDependencies === void 0 ? void 0 : additionalDependencies.devDependencies);
            }
            //get dependencies from config
            const gatherDependencies = (components) => __awaiter(void 0, void 0, void 0, function* () {
                for (const component of components) {
                    const config = yield (0, dependencies_1.getComponentDependencies)(component);
                    // Add dependencies
                    Object.assign(dependenciesToInstall.dependencies, config.dependencies);
                    // Add devDependencies
                    Object.assign(dependenciesToInstall === null || dependenciesToInstall === void 0 ? void 0 : dependenciesToInstall.devDependencies, config === null || config === void 0 ? void 0 : config.devDependencies);
                }
                return dependenciesToInstall;
            });
            //get input based dependencies
            if (input === '--all')
                yield gatherDependencies(yield getAllComponents());
            else if (Array.isArray(input))
                yield gatherDependencies(input);
            //generate install command
            const generateInstallCommand = (deps, flag) => Object.entries(deps)
                .map(([pkg, version]) => {
                // If version is empty or undefined, use 'latest'
                const packageVersion = version && version.trim() !== '' ? version : 'latest';
                return `${pkg}@${packageVersion}`;
            })
                .join(' ') + flag;
            const commands = {
                npm: { install: 'npm install', devFlag: ' --save-dev' },
                yarn: { install: 'yarn add', devFlag: ' --dev' },
                pnpm: { install: 'pnpm i', devFlag: ' -D' },
                bun: { install: 'bun add', devFlag: ' --dev' },
            };
            const { install, devFlag } = commands[versionManager];
            const installCommand = `${install} ${generateInstallCommand(dependenciesToInstall.dependencies, '')}`;
            const devInstallCommand = `${install} ${generateInstallCommand(dependenciesToInstall.devDependencies, devFlag)}`;
            const s = (0, prompts_1.spinner)();
            s.start('⏳ Installing dependencies. This might take a couple of minutes...');
            try {
                if (Object.keys(dependenciesToInstall.dependencies).length > 0) {
                    const installArgs = installCommand.split(' ');
                    const cmd = installArgs.shift();
                    const result = (0, child_process_1.spawnSync)(cmd, installArgs, {
                        cwd: currDir,
                        stdio: 'inherit',
                        shell: true,
                    });
                    if (result.error) {
                        throw new Error(`Failed to install dependencies: ${result.error.message}`);
                    }
                    if (result.status !== 0) {
                        throw new Error(`Install command failed with exit code ${result.status}`);
                    }
                }
                if (Object.keys(dependenciesToInstall.devDependencies).length > 0) {
                    const devInstallArgs = devInstallCommand.split(' ');
                    const devCmd = devInstallArgs.shift();
                    const devResult = (0, child_process_1.spawnSync)(devCmd, devInstallArgs, {
                        cwd: currDir,
                        stdio: 'inherit',
                        shell: true,
                    });
                    if (devResult.error) {
                        throw new Error(`Failed to install dev dependencies: ${devResult.error.message}`);
                    }
                    if (devResult.status !== 0) {
                        throw new Error(`Dev install command failed with exit code ${devResult.status}`);
                    }
                }
                s.stop(`Dependencies have been installed successfully.`);
            }
            catch (err) {
                s.stop(`\x1b[31mFailed to install dependencies.\x1b[0m`);
                prompts_1.log.error(`\x1b[31mError installing dependencies: ${err.message}\x1b[0m`);
                prompts_1.log.warning(`\x1b[33mPlease run the following commands manually:\x1b[0m`);
                if (Object.keys(dependenciesToInstall.dependencies).length > 0) {
                    prompts_1.log.warning(`\x1b[33m${installCommand}\x1b[0m`);
                }
                if (Object.keys(dependenciesToInstall.devDependencies).length > 0) {
                    prompts_1.log.warning(`\x1b[33m${devInstallCommand}\x1b[0m`);
                }
                throw new Error(`Error installing dependencies: ${err.message}`);
            }
        }
        catch (err) {
            throw new Error(err.message);
        }
    });
    exports.installDependencies = installDependencies;
    //function to detect type of project
    function detectProjectType(directoryPath) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const fileChecks = {
                    nextjs: ['next.config.js', 'next.config.mjs', 'next.config.ts'],
                    expo: ['app.json', 'app.config.js', 'app.config.ts'],
                    reactNative: ['ios', 'android'],
                };
                const checkFiles = (files) => __awaiter(this, void 0, void 0, function* () {
                    return (yield Promise.all(files.map((file) => fs_extra_1.default.pathExists(`${directoryPath}/${file}`)))).some(Boolean);
                });
                const isNextJs = yield checkFiles(fileChecks.nextjs);
                const isExpo = yield checkFiles(fileChecks.expo);
                const isReactNative = yield checkFiles(fileChecks.reactNative);
                if (fs_extra_1.default.existsSync(rootPackageJsonPath)) {
                    const packageJson = yield fs_extra_1.default.readJSON(rootPackageJsonPath);
                    const { dependencies } = packageJson;
                    if (isNextJs && (dependencies === null || dependencies === void 0 ? void 0 : dependencies.next)) {
                        return (yield getConfirmation('Detected a Next JS project, continue?'))
                            ? config_1.config.nextJsProject
                            : yield getFrameworkInput();
                    }
                    else if (isExpo &&
                        (dependencies === null || dependencies === void 0 ? void 0 : dependencies.expo) &&
                        dependencies['react-native'] &&
                        !dependencies.next &&
                        !isNextJs &&
                        !isReactNative) {
                        return (yield getConfirmation('Detected an Expo project, continue?'))
                            ? config_1.config.expoProject
                            : yield getFrameworkInput();
                    }
                    else if (isReactNative &&
                        dependencies['react-native'] &&
                        !dependencies.expo) {
                        return (yield getConfirmation('Detected a React Native CLI project, continue?'))
                            ? config_1.config.reactNativeCLIProject
                            : yield getFrameworkInput();
                    }
                }
                const frameworkInput = yield getFrameworkInput();
                return frameworkInput;
            }
            catch (err) {
                prompts_1.log.error(`\x1b[31m${err}\x1b[0m`);
                process.exit(1);
            }
        });
    }
    function getConfirmation(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const confirmInput = yield (0, prompts_1.confirm)({
                message: message,
            });
            if ((0, prompts_1.isCancel)(confirmInput)) {
                (0, prompts_1.cancel)('Operation cancelled.');
                process.exit(1);
            }
            return confirmInput;
        });
    }
    function getFrameworkInput() {
        return __awaiter(this, void 0, void 0, function* () {
            const frameworkInput = yield (0, prompts_1.select)({
                message: 'Please select the framework you are using:',
                options: [
                    {
                        value: config_1.config.nextJsProject,
                        label: 'Next Js',
                    },
                    { value: config_1.config.expoProject, label: 'Expo' },
                    {
                        value: config_1.config.reactNativeCLIProject,
                        label: 'React Native CLI',
                    },
                    {
                        value: 'library',
                        label: 'library',
                    },
                ],
            });
            if ((0, prompts_1.isCancel)(frameworkInput)) {
                (0, prompts_1.cancel)('Operation cancelled.');
                process.exit(1);
            }
            return frameworkInput;
        });
    }
    //regex check for --path input
    function isValidPath(path) {
        const pathRegex = /^(?!\/{2})[a-zA-Z/.]{1,2}.*/;
        return pathRegex.test(path);
    }
    const checkWritablePath = (path) => __awaiter(void 0, void 0, void 0, function* () {
        const confirmPath = yield getConfirmation(`\x1b[33mContinue writing components in the above path? :\x1b[0m [If the path is incorrect, please provide the path from the root of the project]
     \n\x1b[34m${(0, path_1.join)(projectRootPath, path)}
    \x1b[0m`);
        if (!confirmPath)
            process.exit(1);
        return true;
    });
    exports.checkWritablePath = checkWritablePath;
    const checkIfFolderExists = (path) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const stats = yield (0, fs_extra_1.stat)(path);
            return stats.isDirectory();
        }
        catch (error) {
            return false;
        }
    });
    function removeHyphen(str) {
        return str.replace(/-/g, '');
    }
    function getRelativePath({ sourcePath, targetPath, }) {
        const sourceDir = (0, path_1.dirname)(sourcePath);
        const targetDir = (0, path_1.dirname)(targetPath);
        let relativePath = (0, path_1.relative)(sourceDir, targetDir);
        return relativePath === '.' || relativePath === ''
            ? './' + (0, path_1.basename)(targetPath)
            : (0, path_1.join)(relativePath, (0, path_1.basename)(targetPath));
    }
    function ensureFilesPromise(filePaths) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Filter out empty strings, null, and undefined values
                const validPaths = filePaths.filter((path) => path && typeof path === 'string' && path.trim() !== '');
                // Use Promise.all to run all ensureFile operations concurrently
                yield Promise.all(validPaths.map((filePath) => __awaiter(this, void 0, void 0, function* () {
                    // Normalize the path and ensure the file
                    const normalizedPath = filePath.normalize();
                    yield fs_extra_1.default.ensureFile(normalizedPath); // Ensure the file exists asynchronously
                })));
                return true; // All operations successful
            }
            catch (error) {
                console.error('Error ensuring files:', error);
                return false; // At least one operation failed
            }
        });
    }
    const addIndexFile = (componentsDirectory, level = 0) => {
        try {
            const files = fs_extra_1.default.readdirSync(componentsDirectory);
            const exports = files
                .filter((file) => file !== 'index.js' && file !== 'index.tsx' && file !== 'index.ts')
                .map((file) => {
                const stats = fs_extra_1.default.statSync(`${componentsDirectory}/${file}`);
                if (stats.isDirectory()) {
                    if (level === 0) {
                        addIndexFile(`${componentsDirectory}/${file}`, level + 1);
                    }
                    return `export * from './${file.split('.')[0]}';`;
                }
                else {
                    return '';
                }
            })
                .join('\n');
            fs_extra_1.default.writeFileSync((0, path_1.join)(componentsDirectory, 'index.ts'), exports);
        }
        catch (err) {
            prompts_1.log.error(`\x1b[31mError: ${err.message}\x1b[0m`);
        }
    };
    exports.addIndexFile = addIndexFile;
    const pascalToDash = (str) => {
        return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    };
    exports.pascalToDash = pascalToDash;
    const dashToPascal = (str) => {
        return str
            .toLowerCase()
            .replace(/-(.)/g, (_, group1) => group1.toUpperCase())
            .replace(/(^|-)([a-z])/g, (_, _group1, group2) => group2.toUpperCase());
    };
    exports.dashToPascal = dashToPascal;
});
